// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const card = `-- name: Card :one
SELECT id, type, front, back, creator, created, generic FROM cards WHERE id = $1
`

func (q *Queries) Card(ctx context.Context, id int32) (Cards, error) {
	row := q.db.QueryRow(ctx, card, id)
	var i Cards
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Front,
		&i.Back,
		&i.Creator,
		&i.Created,
		&i.Generic,
	)
	return i, err
}

const cardCreate = `-- name: CardCreate :exec
INSERT INTO cards (type, front, back, creator)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CardCreateParams struct {
	Type    string      `json:"type"`
	Front   string      `json:"front"`
	Back    pgtype.Text `json:"back"`
	Creator pgtype.Int4 `json:"creator"`
}

func (q *Queries) CardCreate(ctx context.Context, arg CardCreateParams) error {
	_, err := q.db.Exec(ctx, cardCreate,
		arg.Type,
		arg.Front,
		arg.Back,
		arg.Creator,
	)
	return err
}

const cardDelete = `-- name: CardDelete :exec
DELETE FROM cards WHERE id = $1
`

func (q *Queries) CardDelete(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, cardDelete, id)
	return err
}

const gameCardFlip = `-- name: GameCardFlip :exec
UPDATE game_cards
SET flipped = NOT flipped
WHERE game_cards.game_id = $1
    AND game_cards.card_id = $2
    AND game_cards.id = (
        SELECT game_cards.id
        FROM game_cards
        WHERE game_cards.game_id = $1 AND game_cards.card_id = $2
        LIMIT 1
    )
`

type GameCardFlipParams struct {
	GameID string `json:"game_id"`
	CardID int32  `json:"card_id"`
}

func (q *Queries) GameCardFlip(ctx context.Context, arg GameCardFlipParams) error {
	_, err := q.db.Exec(ctx, gameCardFlip, arg.GameID, arg.CardID)
	return err
}

const gameCardMove = `-- name: GameCardMove :exec


UPDATE game_cards
SET player_id = $1
WHERE game_cards.game_id = $2
    AND game_cards.card_id = $3
    AND game_cards.id = (
        SELECT game_cards.id
        FROM game_cards
        WHERE game_cards.game_id = $2 AND game_cards.card_id = $3
        LIMIT 1
    )
`

type GameCardMoveParams struct {
	PlayerID pgtype.Int4 `json:"player_id"`
	GameID   string      `json:"game_id"`
	CardID   int32       `json:"card_id"`
}

// GameCardCreate
// WITH slots AS (
//
//	SELECT MAX(slot)
//	FROM game_cards
//	WHERE game_id = :game_id
//
// ),
// spin AS (
//
//	SELECT card_id
//	FROM game_cards
//	WHERE game_id = :game_id
//		AND revealed = false
//		AND slot = RANDOM() % (SELECT * FROM slots)
//	ORDER BY stack DESC LIMIT 1
//
// )
// UPDATE game_cards
// SET
//
//	revealed = true,
//	player_id = :player_id
//
// WHERE id = (SELECT card_id FROM spin);
// Moves a single card of matching id to the new player_id provided.
func (q *Queries) GameCardMove(ctx context.Context, arg GameCardMoveParams) error {
	_, err := q.db.Exec(ctx, gameCardMove, arg.PlayerID, arg.GameID, arg.CardID)
	return err
}

const gameCardShred = `-- name: GameCardShred :exec

WITH cte AS (
    SELECT id
    FROM game_cards
    WHERE game_cards.game_id = $1
      AND game_cards.card_id = $2
    LIMIT 1
)
UPDATE game_cards
SET shredded = true
WHERE id IN (SELECT id FROM cte)
`

type GameCardShredParams struct {
	GameID string `json:"game_id"`
	CardID int32  `json:"card_id"`
}

// GameCardClone
func (q *Queries) GameCardShred(ctx context.Context, arg GameCardShredParams) error {
	_, err := q.db.Exec(ctx, gameCardShred, arg.GameID, arg.CardID)
	return err
}

const gameCards = `-- name: GameCards :many
SELECT
    game_cards.id, 
    cards.type, 
    cards.front, 
    cards.back,
    game_cards.stack, 
    game_cards.slot, 
    game_cards.player_id, 
    game_cards.revealed, 
    game_cards.flipped, 
    game_cards.shredded, 
    game_cards.from_clone
FROM game_cards
JOIN cards ON cards.id = game_cards.card_id
WHERE game_cards.game_id = $1
`

type GameCardsRow struct {
	ID        int32       `json:"id"`
	Type      string      `json:"type"`
	Front     string      `json:"front"`
	Back      pgtype.Text `json:"back"`
	Stack     int32       `json:"stack"`
	Slot      int32       `json:"slot"`
	PlayerID  pgtype.Int4 `json:"player_id"`
	Revealed  pgtype.Bool `json:"revealed"`
	Flipped   pgtype.Bool `json:"flipped"`
	Shredded  pgtype.Bool `json:"shredded"`
	FromClone pgtype.Bool `json:"from_clone"`
}

func (q *Queries) GameCards(ctx context.Context, gameID string) ([]GameCardsRow, error) {
	rows, err := q.db.Query(ctx, gameCards, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GameCardsRow
	for rows.Next() {
		var i GameCardsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Front,
			&i.Back,
			&i.Stack,
			&i.Slot,
			&i.PlayerID,
			&i.Revealed,
			&i.Flipped,
			&i.Shredded,
			&i.FromClone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const gameCardsInit = `-- name: GameCardsInit :exec

INSERT INTO game_cards (game_id, card_id, slot, stack, player_id)
(
    SELECT $1, cards.id, 0, 0, 0 -- FIXME: bullshit zeros
    FROM cards
    WHERE generic IS TRUE
)
`

// TODO: this needs a lot of work
func (q *Queries) GameCardsInit(ctx context.Context, gameID string) error {
	_, err := q.db.Exec(ctx, gameCardsInit, gameID)
	return err
}

const gameCreate = `-- name: GameCreate :exec
INSERT INTO games (name, id, owner_id)
VALUES ($1, $2, $3)
RETURNING id
`

type GameCreateParams struct {
	Name    string      `json:"name"`
	ID      string      `json:"id"`
	OwnerID pgtype.Int4 `json:"owner_id"`
}

func (q *Queries) GameCreate(ctx context.Context, arg GameCreateParams) error {
	_, err := q.db.Exec(ctx, gameCreate, arg.Name, arg.ID, arg.OwnerID)
	return err
}

const gameDelete = `-- name: GameDelete :exec
DELETE FROM games WHERE id = $1
`

func (q *Queries) GameDelete(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, gameDelete, id)
	return err
}

const gamePlayerCreate = `-- name: GamePlayerCreate :exec
INSERT INTO game_players (game_id, player_id, session_key, initiative)
VALUES ($1, $2, $3, $4)
`

type GamePlayerCreateParams struct {
	GameID     string      `json:"game_id"`
	PlayerID   int32       `json:"player_id"`
	SessionKey pgtype.Text `json:"session_key"`
	Initiative pgtype.Int4 `json:"initiative"`
}

// session_key is expected to be valid for the duration of the game
func (q *Queries) GamePlayerCreate(ctx context.Context, arg GamePlayerCreateParams) error {
	_, err := q.db.Exec(ctx, gamePlayerCreate,
		arg.GameID,
		arg.PlayerID,
		arg.SessionKey,
		arg.Initiative,
	)
	return err
}

const gamePlayerDelete = `-- name: GamePlayerDelete :exec
DELETE FROM game_players 
WHERE game_id = $1 
	AND player_id = $2
`

type GamePlayerDeleteParams struct {
	GameID   string `json:"game_id"`
	PlayerID int32  `json:"player_id"`
}

func (q *Queries) GamePlayerDelete(ctx context.Context, arg GamePlayerDeleteParams) error {
	_, err := q.db.Exec(ctx, gamePlayerDelete, arg.GameID, arg.PlayerID)
	return err
}

const gamePlayerPoints = `-- name: GamePlayerPoints :many
SELECT 
    player_id,
    (SELECT name FROM players WHERE players.id=game_players.player_id) AS name, 
    points,
    session_key,
    initiative
    player_id,
    (SELECT name FROM players WHERE players.id=game_players.player_id) AS name, 
    points,
    session_key,
    initiative
FROM game_players 
WHERE game_id = $1
ORDER BY initiative ASC
`

type GamePlayerPointsRow struct {
	PlayerID     int32       `json:"player_id"`
	Name         string      `json:"name"`
	Points       pgtype.Int4 `json:"points"`
	SessionKey   pgtype.Text `json:"session_key"`
	PlayerID_2   pgtype.Int4 `json:"player_id_2"`
	Name_2       string      `json:"name_2"`
	Points_2     pgtype.Int4 `json:"points_2"`
	SessionKey_2 pgtype.Text `json:"session_key_2"`
	Initiative   pgtype.Int4 `json:"initiative"`
}

// TODO: is id=player_id correct?
func (q *Queries) GamePlayerPoints(ctx context.Context, gameID string) ([]GamePlayerPointsRow, error) {
	rows, err := q.db.Query(ctx, gamePlayerPoints, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GamePlayerPointsRow
	for rows.Next() {
		var i GamePlayerPointsRow
		if err := rows.Scan(
			&i.PlayerID,
			&i.Name,
			&i.Points,
			&i.SessionKey,
			&i.PlayerID_2,
			&i.Name_2,
			&i.Points_2,
			&i.SessionKey_2,
			&i.Initiative,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const gameState = `-- name: GameState :one
SELECT
    id,
    name,
    owner_id,
    state_id,
    initiative_current,
    (
        SELECT name
        FROM game_states
        WHERE game_states.id = state_id
    ) AS state_name,
    (
        SELECT COUNT(player_id)
        FROM game_players
        WHERE game_players.game_id = games.id
    ) AS player_count
FROM games WHERE games.id = $1
`

type GameStateRow struct {
	ID                string      `json:"id"`
	Name              string      `json:"name"`
	OwnerID           pgtype.Int4 `json:"owner_id"`
	StateID           int32       `json:"state_id"`
	InitiativeCurrent pgtype.Int4 `json:"initiative_current"`
	StateName         string      `json:"state_name"`
	PlayerCount       int64       `json:"player_count"`
}

func (q *Queries) GameState(ctx context.Context, id string) (GameStateRow, error) {
	row := q.db.QueryRow(ctx, gameState, id)
	var i GameStateRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.StateID,
		&i.InitiativeCurrent,
		&i.StateName,
		&i.PlayerCount,
	)
	return i, err
}

const gameUpdate = `-- name: GameUpdate :exec
UPDATE games
SET state_id = $1, initiative_current = $2
WHERE id = $3
`

type GameUpdateParams struct {
	StateID           int32       `json:"state_id"`
	InitiativeCurrent pgtype.Int4 `json:"initiative_current"`
	ID                string      `json:"id"`
}

func (q *Queries) GameUpdate(ctx context.Context, arg GameUpdateParams) error {
	_, err := q.db.Exec(ctx, gameUpdate, arg.StateID, arg.InitiativeCurrent, arg.ID)
	return err
}

const games = `-- name: Games :many
SELECT id, name, created, owner_id, state_id, initiative_current FROM games WHERE id = (
	SELECT game_id 
	FROM game_players
	WHERE player_id = $1
)
`

func (q *Queries) Games(ctx context.Context, playerID int32) ([]Games, error) {
	rows, err := q.db.Query(ctx, games, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Games
	for rows.Next() {
		var i Games
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.OwnerID,
			&i.StateID,
			&i.InitiativeCurrent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const initiativeAdvance = `-- name: InitiativeAdvance :exec
UPDATE games
SET initiative_current = (
    CASE 
        WHEN initiative_current = (
            SELECT MAX(game_players.initiative)
            FROM game_players
            WHERE game_players.game_id = $1
        ) THEN 1
        ELSE initiative_current + 1
    END
)
WHERE games.id = $1
`

func (q *Queries) InitiativeAdvance(ctx context.Context, gameID string) error {
	_, err := q.db.Exec(ctx, initiativeAdvance, gameID)
	return err
}

const initiativeSet = `-- name: InitiativeSet :exec
UPDATE game_players
SET initiative = $1
WHERE game_id = $2
    AND player_id = $3
`

type InitiativeSetParams struct {
	Initiative pgtype.Int4 `json:"initiative"`
	GameID     string      `json:"game_id"`
	PlayerID   int32       `json:"player_id"`
}

func (q *Queries) InitiativeSet(ctx context.Context, arg InitiativeSetParams) error {
	_, err := q.db.Exec(ctx, initiativeSet, arg.Initiative, arg.GameID, arg.PlayerID)
	return err
}

const player = `-- name: Player :one
SELECT id, name, created FROM players WHERE id = $1
`

func (q *Queries) Player(ctx context.Context, id int32) (Players, error) {
	row := q.db.QueryRow(ctx, player, id)
	var i Players
	err := row.Scan(&i.ID, &i.Name, &i.Created)
	return i, err
}

const playerCreate = `-- name: PlayerCreate :one
INSERT INTO players (name) VALUES ($1) RETURNING id
`

func (q *Queries) PlayerCreate(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, playerCreate, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const playerDelete = `-- name: PlayerDelete :exec
DELETE FROM players WHERE id = $1
`

func (q *Queries) PlayerDelete(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, playerDelete, id)
	return err
}
